---
slidebar_position: 4
---

# 2.4 ArduSub & ROSMAV

#### Installing ArduSub

`ROSMAV` is a custom package that enables communication between `ArduSub` and the ROS2 environment. For the purposes of this problem set and future simulations (with QGroundControl), you must install `ArduSub`. When you interface with the ROVs themselves, you'll connect to a `SITL` running onboard and therefore you will not need to run your own.

:::note

You must install ArduSub while you are in a virtual environment on the Raspberry Pi

:::

Open VSCode and `ssh` into your Raspberry Pi. Open the terminal to begin installation.

Install `ArduSub` from the official Git repository on the `backseat`.

```zsh
cd && git clone --recurse-submodules https://github.com/blksail-edu/ardupilot
cd ~/ardupilot
```

Create a new virtual environment for `ArduSub`.

```zsh
mkvirtualenv auv-simulator
```

Install the following dependencies:

```zsh
python3 -m pip install empy==3.3.4 pexpect mavproxy future dronecan setuptools
```

Also install the `ccache` system library:

```zsh
sudo apt-get install ccache
```

Now, configure `ArduPilot`:

```zsh
./waf configure
. ~/.profile
./waf clean
```

On the `backseat`, use the following commands in a terminal to add `ArduPilot` to path:

```zsh
echo "export PATH=$PATH:$HOME/ardupilot/Tools/autotest" >> ~/.zshrc
echo "export PATH=/usr/lib/ccache:$PATH" >> ~/.zshrc
```

Next, install the `gcc-arm cross-compiler`:

```zsh
cd ~/ardupilot && mkdir TARGET_DIR && cd TARGET_DIR
wget -c https://firmware.ardupilot.org/Tools/STM32-tools/gcc-arm-none-eabi-10-2020-q4-major-x86_64-linux.tar.bz2
```

Unpack the compiler:

```zsh
tar -xjvf gcc-arm-none-eabi-10-2020-q4-major-x86_64-linux.tar.bz2
```

Add the compiler to path by using the following terminal command:

```zsh
echo "PATH=$PATH:$HOME/ardupilot/TARGET_DIR/gcc-arm-none-eabi-10-2020-q4-major/bin" >> ~/.zshrc
```

#### Configuring MAVROS

Before you can use `ArduSub`, you must finalize the `MAVROS` installation. We have preinstalled `MAVORS` on your Raspberry Pi, but you must fun the following commands to install an additional library:

```zsh
cd && wget https://raw.githubusercontent.com/mavlink/mavros/ros2/mavros/scripts/install_geographiclib_datasets.sh
chmod +x ./install_geographiclib_datasets.sh
sudo ./install_geographiclib_datasets.sh
```

#### Launching ArduSub

Now, in a terminal on the `backseat`, start a `SITL` with the following command:

```zsh
~/ardupilot/Tools/autotest/sim_vehicle.py --vehicle=ArduSub --aircraft="bwsibot" -L RATBeach --out=udp:YOUR_COMPUTER_IP:14550
```

:::note Note
The first time you start the SITL, it may take some time to configure.
:::

In this section we cover how to connect to the BlueROV2 using a custom `rosmav` interface. This interface uses the `MAVLINK` communication protocal inside of a ROS 2 node to talk to the "*frontseat*" onboard the vehicle.

## Configuring ROSMAV

1. First, create a new virutal environment for the `rosmav` interface.

```zsh
mkvirtualenv rosmav --system-site-packages
workon rosmav
```

2. Install the following libraries in the `rosmav` virtual environment.

```zsh
pip install cv_bridge numpy pymavlink
```

3. Now, clone the `rosmav` repository into the `src` directory of your `auvc_ws`.

```zsh
cd ~/auvc_ws/src && git clone https://github.com/blksail-edu/rosmav
```

4. Install ROS 2 dependencies:

```zsh
cd ../ && rosdep install --from-paths src --ignore-src -r -y
```

5. Compile the `rosmav` package and source the workspace.

```zsh
colcon build --packages-select rosmav && source install/setup.zsh
```

## Launching ROSMAV

After building the `rosmav` package, test the interface by running the following command in a terminal on the backseat:

```zsh
ros2 run rosmav ros_bluerov2_interface
```

If the command runs successfully, you should see the following output:

```zsh
[INFO] [1721669754.194733875] [ros_bluerov2_interface]: Heartbeat from system 1, component 0
```


## Problem Set

For this problem set, please first create a new ROS 2 package named `tutorial_ardusub` to contain any new nodes that you create.

### Problem One

In your `tutorial_ardusub` package, create a new node called `bluerov2_sensors.py`. This node should do the following:

1. Subscribe to the battery sensor messages.
2. Subscribe to the inertial measurement unit \(IMU\) sensor messages.
3. Use attributes that are updated on subscription callbacks.
4. Output a warning in the terminal when the battery has fallen below a safe voltage.

:::info

When both `ArduSub` and `ROSMAV` are running on the `backseat`, the `SITL` will send simulated messages that you can use to test your node.

:::

### Problem Two

Open `QGroundControl` on your Windows or macOs machine. You should see the BlueROV2 somewhere along the United State's west coast. This BlueROV2 is the `SITL` running on the `backseat`.

If it is not already running, start your node from **Problem One**.

In `QGroundControl`, arm the BlueROV2 and change its flight mode to `GUIDED`. Click any arbitrary point in the water and select `Go to location`. After holding down your space bar or dragging the slider, you should see the BlueROV2 moving.

Open a new terminal on the `backseat` and use the `ros2 topic echo` command to inspect the available topics. Also pay attention to your node. What do you observe?

:::warning Check-off

Review with a TA or instructor to check-off this section.

:::
